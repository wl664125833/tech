<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303244 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2048"/>

<div>
<span><div><br/></div><table style="-evernote-table:true;border-collapse:collapse;table-layout:fixed;margin-left:0px;width:100%;"><tbody><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:99.92447129909365%;"><div style="margin: 0px 15px; padding: 16px 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-weight: 600; font-size: 16px;"><div>DOM创建节点及节点属性</div></div><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">通过JavaScript可以很方便的获取DOM节点，从而进行一系列的DOM操作。但实际上一般开发者都习惯性的先定义好HTML结构，但这样就非常不灵活了。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">试想下这样的情况：如果我们通过AJAX获取到数据之后然后才能确定结构的话，这种情况就需要动态的处理节点了</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">本文向大家介绍一下如何使用JavaScript创建div节点元素，主要包括创建div节点元素的属性和创建div节点元素的样式两大部分内容，相信本文介绍一定会让你有所收获。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">先介绍下需要用到的浏览器提供的一些原生的方法（这里不处理低版本的IE兼容问题）</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">创建流程比较简单，大体如下：</p><ol style="margin: 1em 0px; padding: 0px 40px; list-style: decimal; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">创建节点(常见的：元素、属性和文本)</li><li style="margin: 0px; padding: 0px;">添加节点的一些属性</li><li style="margin: 0px; padding: 0px;">加入到文档中</li></ol><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">流程中涉及的一点方法：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">创建元素：document.createElement</li><li style="margin: 0px; padding: 0px;">设置属性：setAttribute</li><li style="margin: 0px; padding: 0px;">添加文本：innerHTML</li><li style="margin: 0px; padding: 0px;">加入文档：appendChild</li></ul><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如右边代码所示，写一个最简单的元素创建，我们会发现几个问题：</p><ol style="margin: 1em 0px; padding: 0px 40px; list-style: decimal; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">每一个元素节点都必须单独创建</li><li style="margin: 0px; padding: 0px;">节点是属性需要单独设置，而且设置的接口不是很统一</li><li style="margin: 0px; padding: 0px;">添加到指定的元素位置不灵活</li><li style="margin: 0px; padding: 0px;">最后还有一个最重要的：浏览器兼容问题处理</li></ol><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>针对这一系列的DOM操作的问题，jQuery给出了一套非常完美的接口方法，我们之后就开始深入学习</div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery节点创建与属性的处理</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">上一节介绍了通过JavaScript原生接口创建节点，在处理上是非常复杂与繁琐的。我们可以通过使用jQuery来简化了这个过程</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">创建元素节点</strong>：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">可以有几种方式，后面会慢慢接触。常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来，通过$()函数处理，$(&quot;html结构&quot;)</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;&lt;div&gt;&lt;/div&gt;&quot;)
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">创建为本节点</strong>：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">与创建元素节点类似，可以直接把文本内容一并描述</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;)
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">创建为属性节点</strong>：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">与创建元素节点同样的方式</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;&lt;div id='test' class='aaron'&gt;我是文本节点&lt;/div&gt;&quot;)
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">我们通过jQuery把上一届的代码改造一下，如右边代码所示</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">一条一句就搞定了，跟写HTML结构方式是一样的</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;)
</pre></div><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>这就是jQuery创建节点的方式，让我们保留HTML的结构书写方式，非常的简单、方便和灵活</div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM内部插入append()与appendTo()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">动态创建的元素是不够的，它只是临时存放在内存中，最终我们需要放到页面文档并呈现出来。那么问题来了，怎么放到文档上？</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">这里就涉及到一个位置关系，常见的就是把这个新创建的元素，当作页面某一个元素的子元素放到其内部。针对这样的处理，jQuery就定义2个操作的方法</p><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><a href="http://img.imooc.com/56cc12f800017b4104480146.jpg" style="outline: 0px; text-decoration: none; color: rgb(7, 130, 193);"><img height="113" src="http://img.imooc.com/56cc12f800017b4104480146.jpg" style="border: 0px; max-width: 400px; clear: both; height: auto;" width="349"></img></a></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">append：这个操作与对指定的元素执行原生的appendChild方法，将它们添加到文档中的情况类似。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">appendTo：实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><br/>
简单的总结就是：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">.append()和.appendTo()两种方法功能相同，主要的不同是语法——内容和目标的位置不同</p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">append()前面是被插入的对象，后面是要在对象内插入的元素内容<br/>
appendTo()前面是要插入的元素内容，而后面是被插入的对象<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM外部插入after()与before()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">节点与节点之前有各种关系，除了父子，祖辈关系，还可以是兄弟关系。之前我们在处理节点插入的时候，接触到了内部插入的几个方法，这节我们开始讲外部插入的处理，也就是兄弟之间的关系处理，这里jQuery引入了2个方法，可以用来在匹配I的元素前后插入内容</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">选择器的描述：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><a href="http://img.imooc.com/57481b6b00018e3405210197.jpg" style="outline: 0px; text-decoration: none; color: rgb(7, 130, 193);"><img src="jquery_DOM_files/Image.jpg" type="image/jpeg" style="border: 0px; max-width: 400px; clear: both; width: 350px;"/></a></p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">before与after都是用来对相对选中元素外部增加相邻的兄弟节点</li><li style="margin: 0px; padding: 0px;">2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面</li><li style="margin: 0px; padding: 0px;">2个方法都支持多个参数传递after(div1,div2,....) 可以参考右边案例代码</li></ul><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">注意点：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入</li><li style="margin: 0px; padding: 0px;">before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插</li></ul><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM内部插入prepend()与prependTo()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">在元素内部进行操作的方法，除了在被选元素的结尾（仍然在内部）通过append与appendTo插入指定内容外，相应的还可以在被选元素之前插入，jQuery提供的方法是prepend与prependTo</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">选择器的描述：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><a href="http://img.imooc.com/57481c3900013c6e05000193.jpg" style="outline: 0px; text-decoration: none; color: rgb(7, 130, 193);"><img src="jquery_DOM_files/Image [1].jpg" type="image/jpeg" style="border: 0px; max-width: 400px; clear: both; width: 350px;"/></a> </p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">通过右边代码可以看到prepend与prependTo的使用及区别：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">.prepend()方法将指定元素插入到匹配元素里面作为它的第一个子元素 (如果要作为最后一个子元素插入用.append()).</li><li style="margin: 0px; padding: 0px;">.prepend()和.prependTo()实现同样的功能，主要的不同是语法，插入的内容和目标的位置不同</li><li style="margin: 0px; padding: 0px;">对于.prepend() 而言，选择器表达式写在方法的前面，作为待插入内容的容器，将要被插入的内容作为方法的参数</li><li style="margin: 0px; padding: 0px;">而.prependTo() 正好相反，将要被插入的内容写在方法的前面，可以是选择器表达式或动态创建的标记，待插入内容的容器作为参数。</li></ul><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">这里总结下内部操作四个方法的区别：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">append()向每个匹配的元素内部追加内容</li><li style="margin: 0px; padding: 0px;">prepend()向每个匹配的元素内部前置内容</li><li style="margin: 0px; padding: 0px;">appendTo()把所有匹配的元素追加到另一个指定元素的集合中</li><li style="margin: 0px; padding: 0px;">prependTo()把所有匹配的元素前置到另一个指定的元素集合中</li></ul><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM外部插入insertAfter()与insertBefore()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">与内部插入处理一样，jQuery由于内容目标的位置不同，然增加了2个新的方法insertAfter与insertBefore</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><a href="http://img.imooc.com/57481d230001b0f305170241.jpg" style="outline: 0px; text-decoration: none; color: rgb(7, 130, 193);"><img src="jquery_DOM_files/Image [2].jpg" type="image/jpeg" style="border: 0px; max-width: 400px; clear: both; width: 350px;"/></a></p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">.before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面</li><li style="margin: 0px; padding: 0px;">.after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面</li><li style="margin: 0px; padding: 0px;">before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理</li></ul><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">注意事项：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入；</li><li style="margin: 0px; padding: 0px;">insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入；</li></ul><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM节点删除之empty()的基本用法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">要移除页面上节点是开发者常见的操作，jQuery提供了几种不同的方法用来处理这个问题，这里我们开仔细了解下empty方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。请看下面的HTML：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
//通过empty处理
$('.hello').empty()

//结果：&lt;p&gt;慕课网&lt;/p&gt;被移除
&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><br/>
可以参考右边的代码区域：</p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">通过empty移除了当前div元素下的所有p元素<br/>
但是本身id=test的div元素没有被删除<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM节点删除之remove()的有参用法和无参用法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">例如一段节点，绑定点击事件</p><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;
$('.hello').on(&quot;click&quot;,fn)
</pre><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如果不通过remove方法删除这个节点其实也很简单，但是同时需要把事件给销毁掉，这里是为了防止&quot;内存泄漏&quot;，所以前端开发者一定要注意，绑了多少事件，不用的时候一定要记得销毁</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">通过remove方法移除div及其内部所有元素，remove内部会自动操作事件销毁方法，所以使用使用起来非常简单</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
//通过remove处理
$('.hello').remove()
//结果：&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 全部被移除
//节点不存在了,同事事件也会被销毁
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">remove表达式参数：</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则，从而这样处理</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">对比右边的代码区域，我们可以通过类似于这样处理</p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">$(&quot;p&quot;).filter(&quot;:contains('3')&quot;).remove()<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM节点删除之empty和remove区别</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">要用到移除指定元素的时候，jQuery提供了empty()与remove([expr])二个方法，两个都是删除元素，但是两者还是有区别</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">empty</strong><strong style="font-style: normal; font-weight: 700;">方法</strong></p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点</li><li style="margin: 0px; padding: 0px;">empty不能删除自己本身这个节点</li></ul><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">remove</strong><strong style="font-style: normal; font-weight: 700;">方法</strong></p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">该节点与该节点所包含的所有后代节点将同时被删除</li><li style="margin: 0px; padding: 0px;">提供传递一个筛选的表达式，删除指定合集中的元素</li></ul><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>以上就是二者的区别，我们具体通过右边代码部分加深理解</div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM节点删除之保留数据的删除操作detach()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><span style="font-size: 10pt;">如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">detach</span><span style="font-size: 10pt;">方法来处理</span></p><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">detach从字面上就很容易理解。让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象。</p><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">来看看jquery官方文档的解释：</p><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。
$(&quot;div&quot;).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。
</pre><p style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><span style="font-size: 10pt;">当然这里要特别注意，</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">detach</span><span style="font-size: 10pt;">方法是</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">JQuery</span><span style="font-size: 10pt;">特有的，所以它只能处理通过</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">JQuery</span><span style="font-size: 10pt;">的方法绑定的事件或者数据</span></p><div style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div><span style="font-size: 10pt;">参考右边的代码区域，通过</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;"> $(&quot;p&quot;).detach()</span><span style="font-size: 10pt;">把所有的</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">P</span><span style="font-size: 10pt;">元素删除后，再通过</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">append</span><span style="font-size: 10pt;">把删除的</span><span lang="EN-US" style="font-size: 10pt; font-family: Arial, sans-serif;">p元素</span><span style="font-size: 10pt;">放到页面上，通过点击文字，可以证明事件没有丢失</span></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM节点删除之detach()和remove()区别</h2><div style="margin: 0px; padding: 0px; word-break: break-all; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden;"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><span style="font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif;">JQuery是一个很大强的工具库，在工作开发中，有些方法因为不常用到，或是没有注意到而被我们忽略。</span></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><span style="font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif;">remove()和detach()可能就是其中的一个，可能remove()我们用得比较多，而detach()就可能会很少了</span></p><div align="left" style="margin: 0.5em 0px; padding: 5px 0px;"><div><span style="color: rgb(31, 36, 38);"><span style="font-size: 12px;"><span style="font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif;"> 通过一张对比表来解释2个方法之间的不同</span></span></span></div><div><img src="jquery_DOM_files/2017-07-13_144119.png" type="image/png" style="height: auto;"/></div><div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(237, 241, 242);"><strong style="font-style: normal; font-weight: 700;">remove</strong><strong style="font-style: normal; font-weight: 700;">：</strong>移除节点</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px; color: rgb(20, 25, 30); font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(237, 241, 242);"><li style="margin: 0px; padding: 0px;">无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据</li><li style="margin: 0px; padding: 0px;">有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据</li></ul><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(237, 241, 242);"><strong style="font-style: normal; font-weight: 700;">detach</strong><strong style="font-style: normal; font-weight: 700;">：</strong>移除节点</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px; color: rgb(20, 25, 30); font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(237, 241, 242);"><li style="margin: 0px; padding: 0px;">移除的处理与remove一致</li><li style="margin: 0px; padding: 0px;">与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来</li><li style="margin: 0px; padding: 0px;">例如：$(&quot;p&quot;).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。</li></ul><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(237, 241, 242); font-size: 12px;"><div>具体可以参考右边的代码区域的对比</div></div></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM拷贝clone()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">克隆节点是DOM的常见操作，jQuery提供一个clone方法，专门用于处理dom的克隆</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
.clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">例如：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
HTML部分
&lt;div&gt;&lt;/div&gt;

JavaScript部分
$(&quot;div&quot;).on('click', function() {//执行操作})

//clone处理一
$(&quot;div&quot;).clone()   //只克隆了结构，事件丢失

//clone处理二
$(&quot;div&quot;).clone(true) //结构、事件与数据都克隆
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">使用上就是这样简单，使用克隆的我们需要额外知道的细节：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css('color','red') 增加了一个颜色</li><li style="margin: 0px; padding: 0px;">通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上</li><li style="margin: 0px; padding: 0px;">clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据</li><li style="margin: 0px; padding: 0px;">元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个</li></ul><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM替换replaceWith()和replaceAll()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">之前学习了节点的内插入、外插入以及删除方法，这节会学习替换方法replaceWith</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.replaceWith( newContent )</strong>：用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">看个简单的例子：一段HTML代码</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;p&gt;第二段&lt;/p&gt;
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">替换第二段的节点与内容</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;p:eq(1)&quot;).replaceWith('&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">通过jQuery筛选出第二个p元素，调用replaceWith进行替换，结果如下</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;第一段&lt;/p&gt;
    &lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;'
    &lt;p&gt;第三段&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.replaceAll( target ) </strong><strong style="font-style: normal; font-weight: 700;">：</strong>用集合的匹配元素替换每个目标元素</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">.replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;').replaceAll('p:eq(1)')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">总结：</p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">.replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别</li><li style="margin: 0px; padding: 0px;">.replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序</li><li style="margin: 0px; padding: 0px;">.replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用</li><li style="margin: 0px; padding: 0px;">.replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点</li></ul><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM包裹wrap()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrap( wrappingElement )</strong><strong style="font-style: normal; font-weight: 700;">：</strong>在集合中匹配的每个元素周围包裹一个HTML结构</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">简单的看一段代码：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;p&gt;p元素&lt;/p&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">给p元素增加一个div包裹</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('p').wrap('&lt;div&gt;&lt;/div&gt;')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">最后的结构，p元素增加了一个父div的结构</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrap( function ) </strong><strong style="font-style: normal; font-weight: 700;">：</strong>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以第一个案例为例：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('p').wrap(function() {
    return '&lt;div&gt;&lt;/div&gt;';   //与第一种类似，只是写法不一样
})
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">注意：</strong></p><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。</div><div><br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM包裹unwrap()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">我们可以通过wrap方法给选中元素增加一个包裹的父元素。相反，如果删除选中元素的父元素要如何处理 ?</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery提供了一个unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">看一段简单案例：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">我要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('div').remove();
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">但是如果我还要保留内部元素p，这样就意味着需要多做很多处理，步骤相对要麻烦很多，为了更便捷，jQuery提供了unwarp方法很方便的处理了这个问题</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('p').unwarp();
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">结果：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;p&gt;p元素&lt;/p&gt;
</pre></div><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>这个方法比较简单，也不接受任何参数，注意参考下案例的使用即可</div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM包裹wrapAll()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">wrap是针对单个dom元素处理，如果要将<strong style="font-style: normal; font-weight: 700; color: rgb(255, 0, 0);">集</strong><span style="color: rgb(255, 0, 0);"><strong style="font-style: normal; font-weight: 700;">合中</strong></span>的元素用其他元素包裹起来，也就是给他们增加一个父元素，针对这样的处理，JQuery提供了一个wrapAll方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrapAll( wrappingElement )</strong><strong style="font-style: normal; font-weight: 700;">：</strong>给集合中匹配的元素增加一个外面包裹HTML结构</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">简单的看一段代码：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;p&gt;p元素&lt;/p&gt;
&lt;p&gt;p元素&lt;/p&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">给所有p元素增加一个div包裹</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('p').wrapAll('&lt;div&gt;&lt;/div&gt;')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">最后的结构，2个P元素都增加了一个父div的结构</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrapAll( function ) </strong><strong style="font-style: normal; font-weight: 700;">：</strong>一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">通过回调的方式可以单独处理每一个元素</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以上面案例为例，</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('p').wrapAll(function() {
    return '&lt;div&gt;&lt;div/&gt;'; 
})
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以上的写法的结果如下，等同于warp的处理了</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">注意：</p><div style="margin: 0px; padding: 0px;"><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>.wrapAll()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套多层，但是最内层只能有一个元素。所有匹配元素将会被当作是一个整体，在这个整体的外部用指定的 HTML 结构进行包裹。</div></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">DOM包裹wrapInner()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如果要将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素，针对这样的处理，JQuery提供了一个wrapInner方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrapInner( wrappingElement )</strong><strong style="font-style: normal; font-weight: 700;">：</strong>给集合中匹配的元素的内部，增加包裹的HTML结构</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">听起来有点绕，可以用个简单的例子描述下，简单的看一段代码：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;p元素&lt;/div&gt;
&lt;div&gt;p元素&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">给所有元素增加一个p包裹</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('div').wrapInner('&lt;p&gt;&lt;/p&gt;')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">最后的结构，匹配的di元素的内部元素被p给包裹了</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.wrapInner( function ) </strong><strong style="font-style: normal; font-weight: 700;">：</strong>允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以上面案例为例，</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('div').wrapInner(function() {
    return '&lt;p&gt;&lt;/p&gt;'; 
})
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以上的写法的结果如下，等同于第一种处理了</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;p&gt;p元素&lt;/p&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">注意：</p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);"> 当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之children()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（<span style="color: rgb(255, 0, 0);">仅儿子辈</span>，<span style="color: rgb(255, 0, 0);">这里可以理解为就是父亲-儿子的关系</span>）</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">代码如果是$(&quot;div&quot;).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">children()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">.<strong style="font-style: normal; font-weight: 700;">children()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一类型选择器表达式</strong></p><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;div&quot;).children(&quot;.selected&quot;)
</pre><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之find()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系）</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">代码如果是$(&quot;div&quot;).find(&quot;li&quot;)，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了。</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">.find()方法要注意的知识点：</strong></p><ul style="margin: 1em 0px; padding: 0px 40px; list-style: disc; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。</li><li style="margin: 0px; padding: 0px;">与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 '*'。</li><li style="margin: 0px; padding: 0px;">find只在后代中遍历，不包括自己。</li><li style="margin: 0px; padding: 0px;">选择器 context 是由 .find() 方法实现的；因此，$('.item-ii').find('li') 等价于 $('li', '.item-ii')(找到类名为item-ii的标签下的li标签)。</li></ul><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">注意重点：</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">.find()和.children()方法是相似的<br/>
1.children只查找第一级的子节点<br/>
2.find查找范围包括子节点的所有后代节点<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之parent()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><span style="color: rgb(255, 0, 0);">因为是父元素，这个方法只会向上查找一级</span></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">查找ul的父元素div, $(ul).parent()，就是这样简单的表达</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">parent()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">parent()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一型选择器表达式</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之parents()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点</p><div style="margin: 0px; padding: 0px;"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;div class=&quot;div&quot;&gt;
    &lt;ul class=&quot;son&quot;&gt;
        &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</pre></div></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">在li节点上找到祖 辈元素div， 这里可以用$(&quot;li&quot;).parents()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">parents()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象;</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">返回的元素秩序是从离他们最近的父级元素开始的</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过parent是匹配合集中所有元素的祖辈元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">parents()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一型选择器表达式</strong></p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">注意事项：</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">1 .parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找<br/>
2  $( &quot;html&quot; ).parent()方法返回一个包含document的集合，而$( &quot;html&quot; ).parents()返回一个空集合。<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之closest()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">closest()</strong><strong style="font-style: normal; font-weight: 700;">方法接受一个匹配元素的选择器字符串</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">例如：在div元素中，往上查找所有的li元素，可以这样表达</p><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;div&quot;).closet(&quot;li')
</pre><div style="margin: 0px; padding: 0px;"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素</strong></p></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">closest()</strong><strong style="font-style: normal; font-weight: 700;">方法给定的</strong><strong style="font-style: normal; font-weight: 700;">jQuery</strong><strong style="font-style: normal; font-weight: 700;">集合或元素来过滤元素</strong></p><div style="margin: 0px; padding: 0px;"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个jQuery的对象</p></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">注意事项：</strong>在使用的时候需要特别注意下</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">粗看.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了</p><ol style="margin: 1em 0px; padding: 0px 40px; list-style: decimal; display: block; font-size: 13px;"><li style="margin: 0px; padding: 0px;">起始位置不同：.closest开始于当前元素 .parents开始于父元素</li><li style="margin: 0px; padding: 0px;">遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合</li><li style="margin: 0px; padding: 0px;">结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象</li></ol><div style="margin: 0px; padding: 0px;"><br/></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之next()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如下class=&quot;item-1&quot;元素就是红色部分，那蓝色的class=&quot;item-2&quot;就是它的兄弟元素</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;ul class=&quot;level-3&quot;&gt;
   <span style="color: rgb(255, 0, 0);"> &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;</span>
    <span style="color: rgb(0, 0, 255);">&lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;</span>
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">next</strong><strong style="font-style: normal; font-weight: 700;">()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象。</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">next</strong><strong style="font-style: normal; font-weight: 700;">()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一类型选择器表达式</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);">同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之prev()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如下蓝色的class=&quot;item-2&quot;的li元素，红色的节点就是它的prev兄弟节点</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;ul class=&quot;level-3&quot;&gt;
    <span style="color: rgb(255, 0, 0);">&lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;</span>
    <span style="color: rgb(0, 0, 205);">&lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;</span>
    &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">prev()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过prev是匹配合集中每一个元素的上一个兄弟元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">prev()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一类型选择器表达式</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</strong></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之siblings()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">理解节点查找关系：</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">如下蓝色的class=&quot;item-2&quot;的li元素，红色的节点就是它的siblings兄弟节点</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;ul class=&quot;level-3&quot;&gt;
   <span style="color: rgb(255, 0, 0);"> &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt;</span>
    <span style="color: rgb(0, 0, 205);">&lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt;</span>
   <span style="color: rgb(255, 0, 0);"> &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;</span>
&lt;/ul&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">siblings()</strong><strong style="font-style: normal; font-weight: 700;">无参数</strong></p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素</strong></pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><strong style="font-style: normal; font-weight: 700;">siblings()</strong><strong style="font-style: normal; font-weight: 700;">方法选择性地接受同一类型选择器表达式</strong></p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);"><strong style="font-style: normal; font-weight: 700;">同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式</strong></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之add()方法</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
.add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">简单的看一个案例：</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">操作：选择所有的li元素，之后把p元素也加入到li的合集中</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;ul&gt;
    &lt;li&gt;list item 1&lt;/li&gt;
    &lt;li&gt;list item 3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新的p元素&lt;/p&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">处理一：传递选择器</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('li').add('p')
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">处理二：传递dom元素</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$('li').add(document.getElementsByTagName('p')[0])
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了</p><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 5px 10px; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; display: block; background: rgb(238, 238, 238);"> $('li').add('&lt;p&gt;新的p元素&lt;/p&gt;').appendTo(目标位置)<br/></div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><h2 style="margin: 0px 15px; padding: 16px 0px; font-size: 16px; font-weight: 600; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(208, 214, 217); font-family: 微软雅黑; color: rgb(20, 25, 30); font-style: normal; font-variant: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;">jQuery遍历之each()</h2><div style="margin: 0px; padding: 0px; color: rgb(20, 25, 30); word-break: break-all; font-family: 'PingFang SC', 微软雅黑, 'Microsoft YaHei', Helvetica, 'Helvetica Neue', Tahoma, Arial, sans-serif; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0px; padding: 0px 15px 15px; word-break: break-all; overflow: hidden; color: rgb(20, 25, 30);"><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。比如我们操作$(&quot;li&quot;).css('') 给所有的li设置style值，因为jQuery是一个合集对象，所以css方法内部就必须封装一个遍历的方法，被称为隐式迭代的过程。要一个一个给合集中每一个li设置颜色，这里方法就是each</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">.each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数</p><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">所以大体上了解3个重点：</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
each是一个for循环的包装迭代器
each通过回调的方式处理，并且会有2个固定的实参，索引与元素
each回调方法中的this指向当前迭代的dom元素
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">看一个简单的案例</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
&lt;ul&gt;
    &lt;li&gt;慕课网&lt;/li&gt;
    &lt;li&gt;Aaron&lt;/li&gt;
&lt;/ul&gt;
</pre></div><p align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;">开始迭代li，循环2次</p><div style="margin: 0px; padding: 0px;"><pre style="margin: 0px; padding: 5px 10px; white-space: pre-wrap; font-family: Monaco, Menlo, 'Ubuntu Mono', Consolas, source-code-pro, monospace; word-wrap: break-word; border: 1px solid rgb(204, 204, 204); border-radius: 2px; font-size: 13px; word-break: break-word; display: block; background: rgb(238, 238, 238);">
$(&quot;li&quot;).each(function(index, element) {
     index 索引 0,1
     element是对应的li节点 li,li
     this 指向的是li
})
</pre></div><div align="left" style="margin: 0.5em 0px; padding: 5px 0px; color: rgb(31, 36, 38); font-size: 12px;"><div>这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循</div></div></div></div></div></td></tr><tr><td style="border-style:solid;border-width:1px;border-color:rgb(211,211,211);padding:10px;margin:0px;width:100%;"><div><br/></div></td></tr></tbody></table><div><br/></div></span>
</div></body></html> 